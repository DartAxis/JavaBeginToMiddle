<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Класс String</title>
</head>
<body>
<h1>Класс String</h1>
<br>
<h3>Вопросы:</h3><br>
<br>
1) Что за тип данных String?<br>
<br>
Строковый тип данных. Финализированный тип.<br>
<br>
2) Варианты создания объектов String<br>
<br>
String s = "Строка";<br>
String s = new String("Строка");<br>
System.out.println("Строка");<br>
<br>

3) Пул строк. что это такое, для чего нужен, как  помещается строка в пул?<br>
<br>
Пул строк это такой массив строк, который возможен благодаря тому что String финализированный тип.<br>
Служит для уменьшения места в памяти которое занимают строковые переменные.<br>
При создании строки через "" проверяется есть ли такая строка в пуле строк,<br>
если нет, то строка добавляется в пул строк и возвращается ссылка на этот элемент<br>
пула. Если в пуле такая строка уже есть то возвращается адрес уже существующей строки.<br>
Если же объект String создается через String s = new String("Строка");<br>
То создается независимый от пула объект String, чтобы поместить такую <br>
строку в пул необходимо у нее вызвать метод intern(). При вызове этого метода<br>
строка также будет проверена на наличие в пуле и возвращена ссылка на элемент пула<br>
если она там есть, и добваиться в пул если ее там нет.<br>
<br>
4) Методы класса String.<br>
<br>
<pre>
1	char charAt(int index)
Возвращает символ по указанному индексу.
2	int compareTo(Object o)
Сравнивает данную строку с другим объектом.
3	int compareTo(String anotherString)
Сравнивает две строки лексически.
4	int compareToIgnoreCase(String str)
Сравнивает две строки лексически, игнорируя регистр букв.
5	String concat(String str)
Объединяет указанную строку с данной строкой, путем добавления ее в конце.
6	boolean contentEquals(StringBuffer sb)
Возвращает значение true только в том случае, если эта строка представляет собой ту же последовательность символов как указанно в буфере строки (StringBuffer).
7	static String copyValueOf(char[] data)
Возвращает строку, которая представляет собой последовательность символов, в указанный массив.
8	static String copyValueOf(char[] data, int offset, int count)
Возвращает строку, которая представляет собой последовательность символов, в указанный массив.
9	boolean endsWith(String suffix)
Проверяет заканчивается ли эта строка указанным окончанием.
10	boolean equals(Object anObject)
Сравнивает данную строку с указанным объектом.
11	boolean equalsIgnoreCase(String anotherString)
Сравнивает данную строку с другой строкой, игнорируя регистр букв.
12	byte getBytes()
Кодирует эту строку в последовательность байтов с помощью платформы charset, сохраняя результат в новый массив байтов.
13	byte[] getBytes(String charsetName
Кодирует эту строку в последовательность байтов с помощью платформы charset, сохраняя результат в новый массив байтов.
14	void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
Копирует символы из этой строки в массив символов назначения.
15	int hashCode()
Возвращает хэш-код для этой строки.
16	int indexOf(int ch)
Возвращает индекс первого вхождения указанного символа в данной строке.
17	int indexOf(int ch, int fromIndex)
Возвращает индекс первого вхождения указанного символа в данной строке, начиная поиск с указанного индекса.
18	int indexOf(String str)
Возвращает индекс первого вхождения указанной подстроки в данной строке.
19	int indexOf(String str, int fromIndex)
Возвращает индекс первого вхождения указанной подстроки в данной строке, начиная с указанного индекса.
20	String intern()
Возвращает каноническое представление для строкового объекта.
21	int lastIndexOf(int ch)
Возвращает индекс последнего вхождения указанного символа в этой строке.
22	int lastIndexOf(int ch, int fromIndex)
Возвращает индекс последнего вхождения указанного символа в этой строке, начиная обратный поиск с указанного индекса.
23	int lastIndexOf(String str)
Возвращает индекс последнего вхождения указанной подстроки в данной строке.
24	int lastIndexOf(String str, int fromIndex)
Возвращает индекс последнего вхождения указанной подстроки в этой строке, начиная обратный поиск с указанного индекса.
25	int length()
Возвращает длину строки.
26	boolean matches(String regex)
Сообщает, соответствует ли или нет эта строка заданному регулярному выражению.
27	boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)
Проверяет равны ли две области строки.
28	boolean regionMatches(int toffset, String other, int ooffset, int len)
Проверяет равны ли две области строки.
29	String replace(char oldChar, char newChar)
Возвращает новую строку, в результате, заменив все вхождения oldChar в этой строке на newChar.
30	String replaceAll(String regex, String replacement)
Заменяет каждую подстроку строки, соответствующей заданному регулярному выражению с данной заменой.
31	String replaceFirst(String regex, String replacement)
Заменяет первые подстроки данной строки, которая соответствует заданному регулярному выражению с данной заменой.
32	String[] split(String regex)
Разделяет эту строку, окружая данным регулярным выражением.
33	String[] split(String regex, int limit)
Разделяет эту строку, окружая данным регулярным выражением.
34	boolean startsWith(String prefix)
Проверяет, начинается ли эта строка с заданного префикса.
35	boolean startsWith(String prefix, int toffset)
Проверяет, начинается ли эта строка с указанного префикса, начиная с указанного индекса.
36	CharSequence subSequence(int beginIndex, int endIndex)
Возвращает новую последовательность символов, которая является подпоследовательностью этой последовательности.
37	String substring(int beginIndex)
Возвращает новую строку, которая является подстрокой данной строки.
38	String substring(int beginIndex, int endIndex)
Возвращает новую строку, которая является подстрокой данной строки.
39	char[] toCharArray()
Преобразует эту строку в новый массив символов.
40	String toLowerCase()
Преобразует все символы в данной строке в нижний регистр, используя правила данного языкового стандарта.
41	String toLowerCase(Locale locale)
Преобразует все знаки в данной строке в нижний регистр, используя правила данного языкового стандарта.
42	String toString()
Этот объект (который уже является строкой!) возвращает себя.
43	String toUpperCase()
Преобразует все символы в строке в верхний регистр, используя правила данного языкового стандарта.
44	String toUpperCase(Locale locale)
Преобразует все символы в строке в верхний регистр, используя правила данного языкового стандарта.
45	String trim()
Возвращает копию строки с пропущенными начальными и конечными пробелами.
46	static String valueOf(primitive data type x)
Возвращает строковое представление переданного типа данных аргумента.</pre>

5) Конкатенация строк.<br>
String s1 = "Hello,";<br>
String s2 = "World!!!";<br>
String s3= s1.concat(s2);<br>
в s3 будет лежать ссылка на строку "Hello,World!!!"<br>
также конкатинировать строки можно через оператор "+"<br>
s3 = s1 + s2; результат будет точно такой же.<br>
<br>
<h3>Задачи:</h3><br>
<br>
1) Напишите метод, который принимает в качестве параметра любую строку, например “I like Java!!!”.<br>
2) Распечатать последний символ строки. Используем метод String.charAt().<br>
3) Проверить, заканчивается ли ваша строка подстрокой “!!!”. Используем метод String.endsWith().<br>
4) Проверить, начинается ли ваша строка подстрокой “I like”. Используем метод String.startsWith().<br>
5) Проверить, содержит ли ваша строка подстроку “Java”. Используем метод String.contains().<br>
6) Найти позицию подстроки “Java” в строке “I like Java!!!”.<br>
7) Заменить все символы “а” на “о”.<br>
8) Преобразуйте строку к верхнему регистру.<br>
9) Преобразуйте строку к нижнему регистру.<br>
10) Вырезать строку Java c помощью метода String.substring().<br>
11*)

<pre>
//    Постановка задачи по валидации скобок Необходимо написать функцию,
//    которая выполняет валидацию строки.Если , строка состоит из скобок составленных по математическим правилам , то результат выполнения функции успех
//    .
//
//      Допустимые символы в строке
//    : открытая круглая скобка , закрытая круглая скобка
//    . Наличие других символов считаем ошибкой входящих параметров - нужно продумать, как обработать эту ситуацию.Примеры
//
//    :
//
//      (), (()), (()()), (()()()) - успешно
//
//      (, ) , )(, ((), ()), ()(, ()(), ())(() - неуспешно

    public static void main(String[] args) {
        System.out.println(check("()"));
        System.out.println(check("(())"));
        System.out.println(check("(()())"));
        System.out.println(check("(()()())"));
        System.out.println(check("("));
        System.out.println(check(")"));
        System.out.println(check(")("));
        System.out.println(check("(()"));
        System.out.println(check("())"));
        System.out.println(check("()()"));
        System.out.println(check("())(()"));

    }
    Вывод на экран должен быть таким:
    true
    true
    true
    true
    false
    false
    false
    false
    false
    false
    false
</pre>
</body>
</html>